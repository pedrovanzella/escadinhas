\documentclass[12pt]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{algorithm2e}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
 \setlength{\leftmargin}{\labelwidth}
 \addtolength{\leftmargin}{\labelsep}
 \renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{sbc-template}

\usepackage[brazil]{babel}

\sloppy

\title{Números Escadinha}

\author{Pedro Vanzella\inst{1}}

\address{Faculdade de Informática -- Pontifícia Universidade Católica do Rio
Grande do Sul (PUCRS) \\ Av. Ipiranga, 6681 - Porto Alegre / RS / Brasil
    \email pedro@pedrovanzella.com}

\makeatother

\usepackage{babel}
\usepackage{listings}
\renewcommand{\lstlistingname}{Listagem}

\begin{document}
\maketitle
\begin{abstract}
A solution for the problem of finding the number of Stairway Numbers
in a arbitrary base-n is proposed.
\end{abstract}
\begin{resumo}
Propõe-se uma solução para o problema de se encontrar a quantidade de Números Escadinha em uma base arbitrária n.
\end{resumo}


\section{Introdução}\label{section:intro}

São chamados Números Escadinha aqueles que seguem um conjunto simples
de regras:
\begin{lyxlist}{00.00.0000}
\item [{1.}] Não começam com o dígito zero
\item [{2.}] Não possuem dígitos repetidos
\item [{3.}] Entre um dígito e o seguinte, a diferença em módulo não é
superior a 2.
\end{lyxlist}
O problema a ser resolvido neste artigo é o de se encontrar quantos
Números Escadinha existem em uma dada base. Fica evidente que eles
são finitos, devido à Regra 2 - o número de dígitos é limitado ao
tamanho da base, senão dígitos começariam a se repetir.


\section{Primeira Tentativa}\label{section:primeira}

Uma tentativa inicial foi feita, tentando o algorítmo mais óbvio e
ingênuo.

Para evitar conversões de base, foi usado um array de inteiros, onde
cada elemento do array representa um dígito do número. O problema
desta parte da solução é que incrementar um dígito roda, na pior das
hipóteses, em tempo linear, oposto a incrementar um inteiro simples,
que deve rodar em tempo constante. Isto é, para cada número a se incrementar,
é necessário verificar o overflow no último dígito. Caso isto ocorra,
faz-se necessário verificar por overflow em cada dígito anterior,
até que não haja mais dígitos em overflow, ou que se tenha chegado
ao começo do array. Este algoritmo foi utilizado em soluções posteriores
pela sua praticidade. 

\subsection{Algorítmos}\label{section:primeira:algoritmos}

O algorítmo de busca por números escadinha faz algumas chamadas a outros algorítmos que valem a pena ser mencionados. Vejamos cada um deles.

\subsubsection{Escadinha}\label{section:primeira:algoritmos:escadinha}
O algoritmo de procura por números válidos é o mais ingênuo possível:
itera por todos os números possíveis na base e, um por um, verifica
se ele se adequa às regras.

\begin{lstlisting}
escadinha(base):
	count = 0
	num = [0] 
	
	enquanto num != maxnum: 
		num = incrementa(num, base) 
		se valido(num):
			count++

	return count
\end{lstlisting}


No algorítmo acima, vemos um {\sf maxnum}.
Ele pode ser facilmente computado gerando um array de base-posições
com $base-1$ em cada posição. 

\subsubsection{Checagem de Validade}\label{section:primeira:algoritmos:valido}
Ainda no algoritmo escadinha, vemos uma chamada para {\sf valido(num, base)}.
Vamos analizar esta chamada, pois nela se encontra o maior problema
de performance deste algorítmo.

\begin{lstlisting}
valido(num):
	para i de 0 a len(num):
		se abs(num[i] - num[i - 1]) > 2:
			return False

	return unique(num)
\end{lstlisting}


Ignorando {\sf unique(num)}, vemos que este algoritmo roda em tempo linear
em relação à quantidade de dígitos de {\sf num}. O problema mesmo, como
veremos, está na verificação de unicidade dos dígitos de um número.
Vejamos o algoritmo que faz isto:

\begin{lstlisting}
unique(num):
	para i de 0 a len(num):
		para j de 0 a len(num):
			se i == j:
				continue 
			se num[i] == num[j]:
				return False 
	return True 
\end{lstlisting}


Claramente, este algoritmo roda em $O(base^{2})$, pois para
cada dígito de {\sf num} (cujo tamanho é igual a {\sf base}), é necessário verificar sua igualdade contra todos
os demais dígitos. Este é um candidato óbvio para otimização. Seria
ideal se, em uma tentativa futura, pudéssemos eliminar completamente
a chamada a este método, tendo a confiança de que só iremos visitar
números cujos dígitos são únicos entre si. No entanto, veremos que apenas otimizar esta parte do algorítmo não reduz a ordem do problema.

\subsubsection{Análise de Complexidade}\label{section:primeira:complexidade}
De fato, vemos que o algoritmo escadinha, considerando tudo, tem uma
complexidade $O(base^{base})$, pois o maior número a ser testado é um de {\sf base}-dígitos-{\sf base-1}, como, por exemplo, $44444$ para base-5.
% TODO: uma explicação melhor %

\subsection{Resultados}\label{section:primeira:resultados}
Obviamente o algoritmo é ruim. Mas quão ruim? Seria possível resolver o problema para uma entrada razoavel? A fim de curiosidade, o algoritmo foi implementado e os resultados podem ser vistos na Tabela~\ref{table:resultados-1}.

\begin{table}[h]
\caption{Primeira Tentativa}
\label{table:resultados-1}
\begin{tabular}{ll}
  {\sf num} & Tempo (s) \\
  \hline
  2 & 0.01 \\
  3 & 0.01 \\
  4 & 0.01 \\
  5 & 0.02 \\
  6 & 0.09 \\
  7 & 1.25 \\
  8 & 23.9 \\
  9 & 540.9    
\end{tabular}
\end{table}

Para entradas menores a 4, a diferença de tempo de execução é imperceptível. Para entradas até 7, vemos um crescimento grande do tempo de execução, mas ainda nada terrível. Para 8, a diferença de tempo já é gritante. Em base-9, o tempo total de execução foi para quase 10 minutos. Esta diferença só aumenta, de maneira assustadora, a cada execução com base mais alta. Fica claro que para base-11 será impossível executar o algorítmo em tempo hábil.

Uma solução mais inteligente é necessária.

\section{Segunda Tentativa}\label{section:segunda}

Como vimos na Parte~\ref{section:primeira:complexidade}, o primeiro algorítmo cresce na ordem de $O(base^{base})$.

Mas a Regra 2 nos diz que não podem haver dígitos repetidos, então este maior número já pode ser descartado. Até onde podemos descartar números, então? Simples: O primeiro dígito será o maior número da base. Os dígitos seguintes serão o dígito anterior, menos um. Este é, claramente, o maior número de uma base.

Infelizmente, como podemos ver na Parte~\ref{section:segunda:resultados}, isto não altera a performance do algorítmo, mesmo reduzindo significativamente a quantidade de números a serem testados. A complexidade do algoritmo continua $O(base^{base})$.

\subsection{Resultados}\label{section:segunda:resultados}

Os resultados da Tabela~\ref{table:resultados-2} são essencialmente iguais aos da Tabela~\ref{table:resultados-1}. Isto é esperado, já que a complexidade do algorítmo não foi alterada.

Precisamos de uma solução mais inteligente ainda.

\begin{table}[h]
\caption{Segunda Tentativa}
\label{table:resultados-2}
\begin{tabular}{ll}
  {\sf num} & Tempo (s) \\
  \hline
  2 & 0.01 \\
  3 & 0.01 \\
  4 & 0.01 \\
  5 & 0.02 \\
  6 & 0.08 \\
  7 & 1.21 \\
  8 & 23.9 \\
  9 & 535.2
  \end{tabular}
  \end{table}

\end{document}
