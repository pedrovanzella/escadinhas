\documentclass[12pt]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{algorithm2e}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
 \setlength{\leftmargin}{\labelwidth}
 \addtolength{\leftmargin}{\labelsep}
 \renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{sbc-template}

\usepackage[brazil]{babel}

\sloppy

\title{Números Escadinha}

\author{Pedro Vanzella\inst{1}}

\address{Faculdade de Informática -- Pontifícia Universidade Católica do Rio
Grande do Sul (PUCRS) \\ Av. Ipiranga, 6681 - Porto Alegre / RS / Brasil
    \email pedro@pedrovanzella.com}

\makeatother

\usepackage{babel}
\usepackage{listings}
\renewcommand{\lstlistingname}{Listagem}

\begin{document}
\maketitle
\begin{abstract}
A solution for the problem of finding the number of Stairway Numbers
in a arbitrary base-n is proposed.
\end{abstract}
\begin{resumo}
Propõe-se uma solução para o problema de se encontrar a quantidade de Números Escadinha em uma base arbitrária n.
\end{resumo}


\section{Introdução}

São chamados Números Escadinha aqueles que seguem um conjunto simples
de regras:
\begin{lyxlist}{00.00.0000}
\item [{1.}] Não começam com o dígito zero
\item [{2.}] Não possuem dígitos repetidos
\item [{3.}] Entre um dígito e o seguinte, a diferença em módulo não é
superior a 2.
\end{lyxlist}
O problema a ser resolvido neste artigo é o de se encontrar quantos
Números Escadinha existem em uma dada base. Fica evidente que eles
são finitos, devido à Regra 2 - o número de dígitos é limitado ao
tamanho da base, senão dígitos começariam a se repetir.


\section{Primeira Tentativa}

Uma tentativa inicial foi feita, tentando o algorítmo mais óbvio e
ingênuo.

Para evitar conversões de base, foi usado um array de inteiros, onde
cada elemento do array representa um dígito do número. O problema
desta parte da solução é que incrementar um dígito roda, na pior das
hipóteses, em tempo linear, oposto a incrementar um inteiro simples,
que deve rodar em tempo constante. Isto é, para cada número a se incrementar,
é necessário verificar o overflow no último dígito. Caso isto ocorra,
faz-se necessário verificar por overflow em cada dígito anterior,
até que não haja mais dígitos em overflow, ou que se tenha chegado
ao começo do array. Este algoritmo foi utilizado em soluções posteriores
pela sua praticidade. 

O algoritmo de procura por números válidos é o mais ingênuo possível:
itera por todos os números possíveis na base e, um por um, verifica
se ele se adequa às regras.

\begin{lstlisting}
escadinha(base):
	count = 0
	num = [0] 
	
	enquanto num != maxnum: 
		num = incrementa(num, base) 
		se valido(num):
			count++

	return count
\end{lstlisting}


No algorítmo acima, vemos um {\sf maxnum}.
Ele pode ser facilmente computado gerando um array de base-posições
com {\sf base-1} em cada posição. 

Ainda no algoritmo escadinha, vemos uma chamada para valido(num, base).
Vamos analizar esta chamada, pois nela se encontra o maior problema
de performance deste algorítmo.

\begin{lstlisting}
valido(num):
	para i de 0 a len(num):
		se abs(num[i] - num[i - 1]) > 2:
			return False

	return unique(num)
\end{lstlisting}


Ignorando {\sf unique(num)}, vemos que este algoritmo roda em tempo linear
em relação à quantidade de dígitos de num. O problema mesmo, como
veremos, está na verificação de unicidade dos dígitos de um número.
Vejamos o algoritmo que faz isto:

\begin{lstlisting}
unique(num):
	para i de 0 a len(num):
		para j de 0 a len(num):
			se i == j:
				continue 
			se num[i] == num[j]:
				return False 
	return True 
\end{lstlisting}


Claramente, este algoritmo roda em O($base^{2}$), pois para
cada dígito de {\sf num} (cujo tamanho é igual a {\sf base}), é necessário verificar sua igualdade contra todos
os demais dígitos. Este é um candidato óbvio para otimização. Seria
ideal se, em uma tentativa futura, pudéssemos eliminar completamente
a chamada a este método, tendo a confiança de que só iremos visitar
números cujos dígitos são únicos entre si. No entanto, veremos que apenas otimizar esta parte do algorítmo não reduz a ordem do problema.

De fato, vemos que o algoritmo escadinha, considerando tudo, tem uma
complexidade O($base^{base}$).

\subsection{Resultados}
Obviamente o algoritmo é ruim. Mas quão ruim? Seria possível resolver o problema para uma entrada razoavel? A fim de curiosidade, o algoritmo foi implementado e os resultados foram os seguintes:

\begin{table}[h]
\caption{Base vs Tempo (s)}
\label{my-label}
\begin{tabular}{ll}
2 & 0.01 \\
3 & 0.01 \\
4 & 0.01 \\
5 & 0.02 \\
6 & 0.09 \\
7 & 1.25 \\
8 & 23.9 \\
9 & 540.9    
\end{tabular}
\end{table}

Para entradas menores a 4, a diferença de tempo de execução é imperceptível. Para entradas até 7, vemos um crescimento grande do tempo de execução, mas ainda nada terrível. Para 8, a diferença de tempo já é gritante. Em base-9, o tempo total de execução foi para quase 10 minutos. Esta diferença só aumenta, de maneira assustadora, a cada execução com base mais alta. Fica claro que para base-11 será impossível executar o algorítmo em tempo hábil.

Fica claro que uma solução mais inteligente é necessária.

\section{Segunda Tentativa}

\end{document}
